package generators

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/DoPlan-dev/CLI/pkg/models"
)

// PRDGenerator generates Product Requirements Document
type PRDGenerator struct {
	projectRoot string
	state       *models.State
}

// NewPRDGenerator creates a new PRD generator
func NewPRDGenerator(projectRoot string, state *models.State) *PRDGenerator {
	return &PRDGenerator{
		projectRoot: projectRoot,
		state:       state,
	}
}

// Generate creates the PRD.md file
func (g *PRDGenerator) Generate() error {
	prdPath := filepath.Join(g.projectRoot, "doplan", "PRD.md")

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(prdPath), 0755); err != nil {
		return fmt.Errorf("failed to create doplan directory: %w", err)
	}

	content := g.generatePRDContent()

	return os.WriteFile(prdPath, []byte(content), 0644)
}

func (g *PRDGenerator) generatePRDContent() string {
	idea := g.state.Idea
	if idea == nil {
		return g.generateEmptyPRD()
	}

	return fmt.Sprintf(`# Product Requirements Document

**Project:** %s
**Version:** 1.0
**Date:** %s
**Status:** Draft

---

## 1. Overview

%s

## 2. Problem Statement

%s

## 3. Solution

%s

## 4. Target Users

%s

## 5. Goals and Objectives

%s

## 6. User Personas

%s

## 7. Features

%s

## 8. Technical Specifications

### Technology Stack

%s

### Architecture

%s

### Infrastructure

%s

## 9. User Flows

%s

## 10. Timeline

%s

## 11. Success Metrics

%s

## 12. Risks and Mitigation

%s

---

*Generated by DoPlan - Project Workflow Manager*
`,
		g.getOrDefault(idea.Name, "Untitled Project"),
		time.Now().Format("2006-01-02"),
		g.getOrDefault(idea.Description, "No description provided."),
		g.getOrDefault(idea.ProblemStatement, "No problem statement provided."),
		g.getOrDefault(idea.Solution, "No solution provided."),
		g.formatList(idea.TargetUsers, "No target users specified."),
		g.formatObjectives(),
		g.formatPersonas(),
		g.formatFeatures(),
		g.formatTechStack(idea.TechStack),
		g.formatArchitecture(),
		g.formatInfrastructure(),
		g.formatUserFlows(),
		g.formatTimeline(),
		g.formatSuccessMetrics(),
		g.formatRisks(),
	)
}

func (g *PRDGenerator) generateEmptyPRD() string {
	return `# Product Requirements Document

**Status:** Empty - Use /Discuss command in Cursor to start idea discussion

---

## Next Steps

1. Use **/Discuss** command in Cursor to start idea discussion
2. Use **/Refine** command to enhance your idea
3. Run **/Generate** command again to generate PRD

---

*Generated by DoPlan - Project Workflow Manager*
`
}

func (g *PRDGenerator) getOrDefault(value, defaultValue string) string {
	if value == "" {
		return defaultValue
	}
	return value
}

func (g *PRDGenerator) formatList(items []string, emptyMessage string) string {
	if len(items) == 0 {
		return emptyMessage
	}
	result := ""
	for _, item := range items {
		result += fmt.Sprintf("- %s\n", item)
	}
	return result
}

func (g *PRDGenerator) formatTechStack(stack []string) string {
	if len(stack) == 0 {
		return "To be determined. Use /Discuss to recommend tech stack."
	}
	result := ""
	for _, tech := range stack {
		result += fmt.Sprintf("- **%s**\n", tech)
	}
	return result
}

func (g *PRDGenerator) formatObjectives() string {
	if len(g.state.Phases) == 0 {
		return "No objectives defined yet. Use /Plan to create phases."
	}
	result := ""
	for i, phase := range g.state.Phases {
		result += fmt.Sprintf("### Phase %d: %s\n", i+1, phase.Name)
		for _, obj := range phase.Objectives {
			result += fmt.Sprintf("- %s\n", obj)
		}
		result += "\n"
	}
	return result
}

func (g *PRDGenerator) formatPersonas() string {
	return "To be defined. Use /Discuss to create user personas."
}

func (g *PRDGenerator) formatFeatures() string {
	if len(g.state.Features) == 0 {
		return "No features defined yet. Use /Plan to create features."
	}
	result := ""
	for _, feature := range g.state.Features {
		result += fmt.Sprintf("### %s\n", feature.Name)
		result += fmt.Sprintf("%s\n\n", feature.Description)
		result += "**Objectives:**\n"
		for _, obj := range feature.Objectives {
			result += fmt.Sprintf("- %s\n", obj)
		}
		result += "\n"
	}
	return result
}

func (g *PRDGenerator) formatArchitecture() string {
	return "To be defined. Use /Generate to create architecture documentation."
}

func (g *PRDGenerator) formatInfrastructure() string {
	return "To be defined. Use /Generate to create infrastructure documentation."
}

func (g *PRDGenerator) formatUserFlows() string {
	if len(g.state.Features) == 0 {
		return "No user flows defined yet. Use /Plan to create features."
	}
	result := ""
	for _, feature := range g.state.Features {
		if feature.UserFlow != "" {
			result += fmt.Sprintf("### %s\n", feature.Name)
			result += fmt.Sprintf("%s\n\n", feature.UserFlow)
		}
	}
	if result == "" {
		return "No user flows defined yet. Use /Plan to create features with user flows."
	}
	return result
}

func (g *PRDGenerator) formatTimeline() string {
	if len(g.state.Phases) == 0 {
		return "No timeline defined yet. Use /Plan to create phases."
	}
	result := "### Phase Timeline\n\n"
	for i, phase := range g.state.Phases {
		result += fmt.Sprintf("**Phase %d: %s**\n", i+1, phase.Name)
		if phase.StartDate != "" {
			result += fmt.Sprintf("- Start: %s\n", phase.StartDate)
		}
		if phase.TargetDate != "" {
			result += fmt.Sprintf("- Target: %s\n", phase.TargetDate)
		}
		if phase.Duration != "" {
			result += fmt.Sprintf("- Duration: %s\n", phase.Duration)
		}
		result += "\n"
	}
	return result
}

func (g *PRDGenerator) formatSuccessMetrics() string {
	return "To be defined. Use /Discuss to define success metrics."
}

func (g *PRDGenerator) formatRisks() string {
	return "To be defined. Use /Discuss to identify risks and mitigation strategies."
}
